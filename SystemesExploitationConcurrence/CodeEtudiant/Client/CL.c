
#include "./Client/CL_include.h"
#include "CL_Connection.h"


void litbuf1();
void litbuf2();
void signal_handler0();
void signal_handler1();

int pipe_fd1[2];
int pipe_fd2[2];
int* pipe_fd[2];

int voie;
int pid0 , pid1;

Connection errConn;

int main(int argc, char *argv[])
{
	// Number of iterations - time
	int nb_iteration = 100;
	  if(argc < 2) {
		printf("!!!! Usage : Client  <+/-nombre de donnees>\n");
		//return -1;
	  } else {
		nb_iteration = atoi(argv[1]);
	  }



	// Create the pipe
	pipe(pipe_fd1);
	pipe(pipe_fd2);
	pipe_fd[0] = pipe_fd1;
	pipe_fd[1] = pipe_fd2;

	// Print the header of the Client
	printf("\n* * * * * * * * * * * * * * * * * * * * * * * * *\n");
	printf("Projet CLIENT - SERVEUR\tTemps RÃ©el E2i - Novembre\n");
	printf("* * * * * * * * * * * * * * * * * * * * * * * * *\n");
	printf("\nLancement du client pendant %d secondes\n", nb_iteration);
	
	// Connection to the server
	errConn = Connect();
	printf("Connection SUCCESS: %d\n",errConn.err);

	// Create the child process channel 0
	pid0 = fork();
	if (pid0 == 0) { // Child ch 0 - Lecteur/Redacteur voie 0
		voie = 0;
        printf("Child 0\n");
		signal(SIGUSR1, litbuf1);
    } else { // Parent
        close(pipe_fd[0][0]); // Close read end
		close(pipe_fd[0][1]); // Close write end
	
		// Create the child process channel 1
		pid1 = fork();
		if (pid1 == 0) { // Child ch 1 - Lecteur/Redacteur voie 1
			voie = 1;
			printf("Child 1 \n");
			signal(SIGUSR2, litbuf2);
		} else { // Parent
		    close(pipe_fd[1][0]); // Close read end
			close(pipe_fd[1][1]); // Close write end
			
			// Signal handling
			signal(SIGTERM, Disconnect);
			signal(SIGINT, Disconnect);
			signal(SIGUSR1, signal_handler0);
			signal(SIGUSR2, signal_handler1);

				// Wait for the time to pass and disconnect
			while(nb_iteration > 0){
				sleep(1);
				nb_iteration--;
				// Wait for the server to send a signal
			}

			return Deconnect();
		}
    }

	
	// Wait for the time to pass and disconnect
	while(nb_iteration > 0){
		sleep(1);
		nb_iteration--;
		// Wait for the server to send a signal
	}

return 0;
}	   	   


//Run the reader thread for nb_iteration
int Lecteur(int voie){
	key_t cle = errConn.key;
	//shmget: get the shared memory
    int CLTshmid = shmget(cle,2*sizeof(BUF),0666|IPC_CREAT);
	if (CLTshmid == -1) {
        perror("shmget");
        exit(1);
    }
    //shmat: attach the shared memory
    BUF *MemTamponPtr = (BUF *)shmat(CLTshmid,NULL,0);
	if (MemTamponPtr == (void *)-1) {
        perror("shmat");
        exit(1);
    }

	//printf("Lecture de la voie 0, Cle: %d\n", cle);
	// Get the data from the shared memory
	int index = (MemTamponPtr+voie)->n;
	int data = (MemTamponPtr+voie)->tampon[index];
	//printf("Adresse %p, Data: %d, Index: %d\n", MemTamponPtr,data,index);

	//shmdt: detach the shared memory
	if (shmdt(MemTamponPtr) == -1) {
		perror("shmdt");
		exit(1);
	}

	// Write the data to the writer
	write(pipe_fd[voie][1], &data, sizeof(int));
	return  data;
}

//Run the redactor thread for nb_iteration
void Redacteur(int voie){
	// declare the buffer and the times as static to keep the values
	static int times[2];
	static int buffer1[5];
	static int buffer2[5];
	int* buffer[2];
	buffer[0] = buffer1;
	buffer[1] = buffer2;

	// Read the data from the reader
	read(pipe_fd[voie][0], &buffer[voie][times[voie]], sizeof(int));
	times[voie]++;
	if(times[voie] == 5){
		// Print the data
		printf("\n");
		for(int i = 0; i < 5; i++){
			printf("Data: %d, Voie: %d\n", buffer[voie][i],voie);
		}
		times[voie] = 0;
	}
}


// Signal handling from the lecteur and redacteur processes
	   	   	   
/*/////////////////////////////////////////////////////////////////////////*/
	   
void litbuf1() /* semaphore 0 */
{
	// Signal handling
	if(voie == 1) return;
	signal(SIGUSR1,litbuf1);
	//printf("Signal recu par le main voie 0\n");

	// Run the reader and the writer
	Lecteur(voie);
	Redacteur(voie);
	
}


void litbuf2() /* semaphore 1 */
{	
	if(voie == 0) return;

	// Signal handling
	signal(SIGUSR2,litbuf2);
	//printf("Signal recu par le main voie 1\n");

	// Run the reader and the writer
	Lecteur(voie);
	Redacteur(voie);
}

// Signal handling from moniteur process
// talk to the lecteur of channel 0 when the signal is received
void signal_handler0() {
	signal(SIGUSR1, signal_handler0);
	kill(pid0,SIGUSR1);
}

// talk to the lecteur of channel 1 when the signal is received
void signal_handler1() {
	signal(SIGUSR2, signal_handler1);
	kill(pid1,SIGUSR2);
}