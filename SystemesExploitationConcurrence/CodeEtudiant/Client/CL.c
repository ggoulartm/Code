
#include "./Client/CL_include.h"
//#include "./Client/redacteur.h"
//#include "./Client/lecteur.h"
#include "CL.h"


void litbuf1();
void litbuf2();

int voie;			/*variable globale (numero du canal a lire)*/

int CreationMessagerie(char *Cle){
	key_t key;
	int  msqid;
	if(Cle == NULL) 
	{
		if (( key = ftok(CleServeur,'M')) < 0 ) return CLEerr;
	}
	else {
		if (( key = ftok(Cle,'M')) < 0 ) return CLEerr;
	}
	msqid = msgget(key,0666|IPC_CREAT);
	return msqid;
}



//Connect send to the server the PID of the client
//with the type CONNECT and just after send the ACK
//Return 0 if the message is sent, -1 otherwise
Connection Connect(){
	dmsgbuf message;
	pid_t ClientPID = getpid();    
	printf("Connect Client PID: %d\n", ClientPID);
	pid_t msqid = CreationMessagerie(NULL);
	message.type=CONNECT;
	sprintf(message.txt,  "%d", ClientPID);
	msgsnd(msqid,&message,L_MSG,IPC_NOWAIT);
	message.type=ClientPID;
	msgrcv(msqid,&message,L_MSG,message.type,0);
	printf("Message (type: %ld) Reçu do Serveur: %s\n", message.type,message.txt);
	//Connection Instance
	Connection conn;
	conn.pid = ClientPID;
	conn.msqid = msqid;
	conn.key = message.txt;
	////////////////////////////
	//////apres reception de la cle du serveur
	message.type=ACK;
	sprintf(message.txt,  "%d", ClientPID);
	conn.err = msgsnd(msqid,&message,L_MSG,IPC_NOWAIT);
	printf("Message (type: %ld) Reçu do Serveur: %s\n", message.type,message.txt);
	return conn;
}

//Deconnect send to the server the PID of the client and type DECONNECT
int Deconnect() {
	pid_t ClientPID = getpid();  
	printf("Deconnect Client PID: %d\n", ClientPID);
	pid_t MsqID = CreationMessagerie(NULL);
	dmsgbuf message;
	message.type=DECONNECT;
	sprintf(message.txt,  "%d", ClientPID);
	return msgsnd(MsqID,&message,L_MSG,IPC_NOWAIT);
}
/*

//Run the reader thread for nb_iteration
int Lecteur(int nb_iteration, pthread_t thread1, int *Cptr){
	int err;
	err = pthread_create(&thread1, NULL, Lecteur_Start, (void *)Cptr);
	if(err != 0){
		printf("Error creating the thread\n");
		return 1;
	}
	return 0;
}

//Run the redactor thread for nb_iteration
int Redacteur(int nb_iteration, pthread_t thread2, int *Cptr){
	int err;
	err = pthread_create(&thread2, NULL, Redacteur_Start, Cptr);
	if(err != 0){
		printf("Error creating the thread\n");
		return 1;
	}
	return 0;
}

*/

int main(int argc, char *argv[])
{
	  /* ... */

	  if(argc < 2) {
		printf("!!!! Usage : Client  <+/-nombre de donnees>\n");
		return 1;
	  }


	signal(SIGUSR1, litbuf1);
	signal(SIGUSR2, litbuf2);

	int nb_iteration = atoi(argv[1]);

	printf("\n* * * * * * * * * * * * * * * * * * * * * * * * *\n");
	printf("Projet CLIENT - SERVEUR\tTemps Réel E2i - Novembre\n");
	printf("* * * * * * * * * * * * * * * * * * * * * * * * *\n");
	printf("\nLancement du client pendant %d secondes\n", nb_iteration);
	

	Connection errConn = Connect();
	printf("Connection SUCCESS: %d\n",errConn.err);
/*
	pthread_t thread1, thread2;

	//Lecteur
	//Run the reader thread for nb_iteration
	int err_ = Lecteur(nb_iteration, thread1, &err);
	if (err_ != 0) {
		pthread_exit(NULL);
		Deconnect();
		return err_;
	}

	//Redacteur
	//Run the redactor thread for nb_iteration
	err_ = Redacteur(nb_iteration, thread2, &err);
		if (err_ != 0) {
		pthread_exit(NULL);
		Deconnect();
		return err_;
	}

	//Wait for the threads to finish
	pthread_join(thread1, NULL);
  	pthread_join(thread2, NULL);
	
	//Exit the thread
	//Don't forget to deconnect the client
	pthread_exit(NULL);
	*/

return Deconnect();
}	   	   

	   	   	   
/*/////////////////////////////////////////////////////////////////////////*/
	   
void litbuf1() /* semaphore 0 */
{
	voie=0;
	signal(SIGUSR1,litbuf1);
}


/*/////////////////////////////////////////////////////////////////////////*/

void litbuf2()
{
	voie=1;	
	signal(SIGUSR2,litbuf2);
}
